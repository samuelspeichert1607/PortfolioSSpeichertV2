#define _USE_MATH_DEFINES

#include "Minion.h"
//Sam
Minion::Minion()
{
	target = nullptr;
}


//Sam
Minion::~Minion()
{
	if (target != nullptr)
	{
		delete target;
	}

	Vector2f * temp = ordreAAttaquer.Pop();
	do
	{
		if (temp != nullptr)
		{
			delete temp;
		}
		temp = ordreAAttaquer.Pop();
	} while (temp != NULL);

	ObjetDeJeu * temp2 = ordreDesSpells.Pop();
	do
	{
		if (temp != nullptr)
		{
			delete temp2;
		}
		temp2 = ordreDesSpells.Pop();
	} while (temp2 != NULL);
}

//Alex et Sam
bool Minion::ajustementsVisuels()
{
	IntRect intRect = IntRect();
	if (minionType == _Tour)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\Tour.png"))
		{
			return false;
		}
		setTexture(texture);
		setOrigin(getGlobalBounds().width / 2, getGlobalBounds().height / 2);
		return true;
	}
	else if (minionType == _Archer)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);
		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 0;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 2;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 0;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 0;
		}
	}
	else if (minionType == _Barbare)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);

		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 1;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 3;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 1;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 0;
		}
	}
	else if (minionType == _Cavalier)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);

		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 0;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 1;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 3;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 3;
		}
	}
	else if (minionType == _GuerrierLeger)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);

		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 2;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 1;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 2;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 2;
		}
	}
	else if (minionType == _GuerrierLourd)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);

		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 1;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 1;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 1;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 2;
		}
	}
	else if (minionType == _Lancier)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);

		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 2;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 0;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 3;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 2;
		}
	}
	else if (minionType == _Magichien)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\characters_size_ok.png"))
		{
			return false;
		}
		//Chargement du fichier de texture et placement dans le sprite.
		setTexture(texture);

		//Tableau de frames dépendant du nombre d'animations
		if (isAlly)
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 0;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 3;
		}
		else
		{
			intRect.left = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL) * 4;
			intRect.top = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL) * 2;
		}
	}
	intRect.width = (texture.getSize().x / NB_SPRITES_DANS_TEXTURE_HORIZONTAL);
	intRect.height = (texture.getSize().y / NB_SPRITES_DANS_TEXTURE_VERTICAL);
	//Le rectangle de notre texture est le premier rectangle.
	setTextureRect(intRect);
	setOrigin(getGlobalBounds().width / 2, getGlobalBounds().height / 2);
	return true;
}
//alex
bool Minion::gotHit(int damage)
{
	health -= damage;
	if (health < 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}
//alex
MinionType Minion::getMinionType() const
{
	return minionType;
}

//Sam
int Minion::getHealth() const
{
	return health;
}

//Sam
int Minion::getMaxHealth() const
{
	return maxHealth;
}

//Minion * Minion::clone()
//{
//	//return new Minion();
//}

/// <summary>
/// Permet seulement de vérifier si une position x/y est à l'intérieur du cercle
/// </summary>
/// <param name="posX">La position en x.</param>
/// <param name="PosY">La position en y.</param>
/// <returns></returns>
//Alex
bool Minion::cliquer(float posX, float posY)
{
	return getGlobalBounds().intersects(FloatRect(posX, posY, 1, 1));
}
//Alex
void Minion::bouger(Liste<Minion>* minionList)
{
	//Une destination nulle pas de mouvement
	if (target != nullptr)
	{
		//On sauvegarde la position précédente au cas
		positionBackup = new Vector2f(getPosition());

		//On effectue le déplacement
		Transformable::move(cos(angle) * speed, sin(angle) * speed);

		//Vue la faible vitesse et pour garder les choses simples, s'il y a collision, on annule 
		//tout simplement le mouvement pour ce refresh de frame et on termine la méthode immédiatement
		for (int i = 0; i < minionList->getNbElements(); i++)
		{
			if (testCollisionMinion((minionList->at(i))))
			{
				backup();
				return;
			}
		}

		//À PARTIR D'ICI C'EST QU'IL N'Y A PAS EU DE COLLISION

		//Avec les float, il faut accepter un seuil de tolérance, quand on arrive à distance de la "vitesse" visé, on considère avoir atteint notre destination
		if ((abs(target->x - getPosition().x) <= speed) && (abs(target->y - getPosition().y) <= speed))
		{
			//On la fixe, pour être certain
			setPosition(*target);
			delete target;
			//On arrête de bouger
			if (isModeManual == true)
			{
				arreter();
			}
			else if (isModeManual == false)
			{
				calculerAngle();
			}
		}
		//Dans tous les cas, pour éviter les leaks on libère le backup
		cleanBackup();
	}
	else if (isModeManual == true)
	{
		arreter();
	}
	else if (isModeManual == false)
	{
		calculerAngle();
	}
}

//Sam
void Minion::arreter()
{
	if (target != nullptr)
	{
		delete target;
		target = nullptr;
		isModeManual = true;
	}
}
//Alex
void Minion::backup()
{
	if (positionBackup != nullptr)
	{
		setPosition(*positionBackup);
		delete positionBackup;
		positionBackup = nullptr;
	}
}
//Alex
void Minion::cleanBackup()
{
	if (positionBackup != nullptr)
	{
		delete positionBackup;
		positionBackup = nullptr;
	}
}

/// <summary>
/// Tester la collision des Minions.  Algo de collision des cercles que vous connaissez déjà
/// </summary>
/// <param name="autreMinion">The autre Minion.</param>
/// <returns>vrai si nous sommes en colision avec un autre Minion, sionon faux</returns>
//Alex
bool Minion::testCollisionMinion(Minion* autreMinion)
{
	//S'assurer qu'on est pas avec null ou avec sois-même.  parce qu'on collisionne toujours avec soit-même...
	if (autreMinion == nullptr || autreMinion == this || autreMinion->getMinionType() == _Tour && autreMinion->getIsDead())
	{
		return false;
	}

	return getGlobalBounds().intersects(autreMinion->getGlobalBounds());
}

/// <summary>
/// donne un projectile qui va dans la direction du target du minion
/// </summary>
//Alex
Projectile * Minion::attack()
{
	if (attackTime.getElapsedTime().asMilliseconds() >= (50 - speed) * 2)
	{
		attackTime.restart();
		float angleProjectile = atanf(((target->y - getPosition().y)) / (target->x - getPosition().x));
		if (target->x < getPosition().x)
		{
			angleProjectile += M_PI;
		}
		Projectile* ARetourner = new Projectile(speed, attackPoints, range, angleProjectile, isAlly);
		ARetourner->setPosition(Vector2f(getPosition().x + cos(angleProjectile) * (getOrigin().x + ARetourner->getOrigin().x), getPosition().y + sin(angleProjectile) * (getOrigin().y + ARetourner->getOrigin().y)));
		return ARetourner;
	}
	else
	{
		return NULL;
	}
}
//alex
Vector2f* Minion::getTarget() const
{
	return target;
}
//Sam
int Minion::getCout() const
{
	return cout;
}
//Sam
int Minion::getRange() const
{
	return range;
}
//Sam
int Minion::getAttackPoints() const
{
	return attackPoints;
}
//Sam
int Minion::getSpeed() const
{
	return speed;
}
/// <summary>
/// ajoute une destination donnée
/// ne pas oublier d'appler calculerAngle lorque nous voulons utiliser le contenu de la liste
/// </summary>
/// <param name="autreMinion">la destination à ajouter</param>
//Alex
void Minion::AjouterDestination(const Vector2f& positionCible)
{
	if (target != nullptr)
	{
		ordreAAttaquer.Push(target);
	}
	ordreAAttaquer.Push(new Vector2f(positionCible));

	calculerAngle();
}
//Sam
void Minion::AjouterSpell(ObjetDeJeu * newSpell)
{
	ordreDesSpells.Push(newSpell);
}

/// <summary>
/// met la prochaine destination et calcule l'angle d'attaque
/// </summary>
//Alex
void Minion::calculerAngle()
{
	target = ordreAAttaquer.Pop();
	if (target != NULL)
	{
		//On calcule l'angle pour la direction de la soul.
		angle = atanf(((target->y - getPosition().y)) / ((target->x - getPosition().x)));

		if (target->x < getPosition().x)
		{
			angle += M_PI;
		}
	}
}
/// <summary>
/// trouve si un ennemi est à porté d'attaque et le met comme sa cible
/// </summary>
/// <returns>vrai si nous avons trouvé un ennemie à porté, sionon faux</returns>
//Alex et Sam
bool Minion::lookForEnnemies(Liste<Minion>* minionList)
{
	float distanceAcceptable = range  * 12 / 50 /*+ attackPoints * 30 / 200*/;
	if (distanceAcceptable < 5)
	{
		distanceAcceptable = range;
	}
	for (int i = 0; i < minionList->getNbElements(); i++)
	{
		if (minionList->at(i) == nullptr || minionList->at(i) == this || minionList->at(i)->getMinionType() == _Tour && minionList->at(i)->getIsDead())
		{
			//Oui oui, le if est vide, c'est awkward... Mais cest fait pour éviter qu'il attaque quelqu'un de "mort".
		}
		else if (minionList->at(i)->getIsAlly() != isAlly && sqrt(pow(minionList->at(i)->getPosition().x - getPosition().x, 2) +
			pow(minionList->at(i)->getPosition().y - getPosition().y, 2)) <= distanceAcceptable +
			sqrt(pow(minionList->at(i)->getOrigin().x, 2) + pow(minionList->at(i)->getOrigin().y, 2)) + sqrt(pow(getOrigin().x, 2) +
			pow(getOrigin().y, 2)))
		{
			//Probleme de vecteur gauche ici!!!! Le target sera à un moment donné à NULL
			if (target == nullptr || (*target).x != minionList->at(i)->getPosition().x || (*target).y != minionList->at(i)->getPosition().y)
			{
				AjouterDestination(Vector2f(minionList->at(i)->getPosition().x, minionList->at(i)->getPosition().y));
			}
			return true;
		}
	}
	return false;
}
//Sam
bool Minion::getIsFacingLeft() const
{
	return isFacingLeft;
}

//Sam
void Minion::notifier(Sujet * sujet)
{
	if (typeid(*sujet) == typeid(Radiation))
	{
		Radiation *b = (Radiation*)sujet;

		float distanceX = abs(b->getPosition().x - getPosition().x);
		float distanceY = abs(b->getPosition().y - getPosition().y);

		float distance = sqrtf(distanceX * distanceX + distanceY * distanceY);
		float dommage = (750 - distance) / 5;

		if (dommage < 0)
		{
			dommage = 0;
		}

		health -= dommage;
	}
	
}
//alex
int Minion::getID() const
{
	return ID;
}
//Alex
int Minion::getIsAlly() const
{
	return isAlly;
}

//Sam
Pile<Vector2f> Minion::getOrdreAAttaquer() const
{
	return ordreAAttaquer;
}

//Sam
Pile<ObjetDeJeu> Minion::getOrdreDesSpells()const
{
	return ordreDesSpells;
}

//Alex
bool Minion::getIsDead() const
{
	return isDead;
}
//Alex
void Minion::die()
{
	isDead = true;
}





////LES OPERATORS!!!

//sam
bool Minion::operator < (const Minion& minion) const
{
	return this->ID < minion.ID;
}
//sam
bool Minion::operator >(const Minion& minion) const
{
	return this->ID > minion.ID;
}
//sam
bool Minion::operator >= (const Minion& minion) const
{
	return this->ID >= minion.ID;
}
//sam
bool Minion::operator <= (const Minion& minion) const
{
	return this->ID <= minion.ID;
}
//sam
bool Minion::operator == (const Minion& minion) const
{
	return this->ID == minion.ID;
}
//sam
bool Minion::operator != (const Minion& minion) const
{
	return this->ID != minion.ID;
}