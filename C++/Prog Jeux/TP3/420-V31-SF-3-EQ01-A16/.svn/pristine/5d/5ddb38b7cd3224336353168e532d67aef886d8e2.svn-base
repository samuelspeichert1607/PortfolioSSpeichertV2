#define _USE_MATH_DEFINES
#include "Minion.h"
//Alex
Minion::Minion()
{
	int noTourSuivante = rand() % 3;
	int tours[3];
	tours[0] = noTourSuivante;
	while (noTourSuivante == tours[0])
	{
		noTourSuivante = rand() % 3;
	}
	tours[1] = noTourSuivante;
	while (noTourSuivante == tours[0] || noTourSuivante == tours[1])
	{
		noTourSuivante = rand() % 3;
	}
	tours[2] = noTourSuivante;
	for (int i = 0; i < 3; i++)
	{
		if (tours[i] == 0)
		{
			AjouterDestination(Vector2f(LARGEUR_ECRAN - 64, HAUTEUR_ECRAN / 4));
		}
		else if (tours[i] == 1)
		{
			AjouterDestination(Vector2f(LARGEUR_ECRAN - 64, HAUTEUR_ECRAN / 2));
		}
		else if (tours[i] == 2)
		{
			AjouterDestination(Vector2f(LARGEUR_ECRAN - 64, HAUTEUR_ECRAN * 3 / 4));
		}
	}
	AjouterDestination(Vector2f(LARGEUR_ECRAN / 2, (float)(rand() % (int)HAUTEUR_ECRAN)));
	calculerAngle();
}

Minion::~Minion()
{

}

bool Minion::ajustementsVisuels()
{
	if (minionType == _Tour)
	{
		if (!texture.loadFromFile("..\\..\\Sprites\\Tour.png"))
		{
			return false;
		}
		setTexture(texture);
		setOrigin(getLocalBounds().width / 2, getLocalBounds().height / 2);
	}
	////Chargement du fichier de texture et placement dans le sprite.
	//SetTexture(texturePath);

	////Tableau de frames dépendant du nombre d'animations
	//intRects = new IntRect[nbrAnims];

	////On se découpe des rectangles d'animation à partir des caractérisitques de la spriteSheet
	////Et de la ligne d'animation
	//for (int i = 0; i < nbrAnims; i++)
	//{
	//	intRects[i].left = (texture.getSize().x / nbrAnims) * i;
	//	intRects[i].top = (texture.getSize().y / nbrNiveaux) * niveau;
	//	intRects[i].width = (texture.getSize().x / nbrAnims);
	//	intRects[i].height = (texture.getSize().y / nbrNiveaux);
	//}

	////Le rectangle de notre texture est le premier rectangle.
	//setTextureRect(intRects[0]);

	////L'origine est toujours le milieu de notre texture.  Mais on la calcule en fonction de la taille d'UNE image, pas de la texture entière
	//setOrigin((texture.getSize().x / nbrAnims) / 2, (texture.getSize().y / nbrNiveaux) / 2);
}

int Minion::gotHit(int damage)
{
	return 0;
}

int Minion::getHealth()
{
	return 0;
}

int Minion::getMaxHealth()
{
	return 0;
}

//Minion * Minion::clone()
//{
//	//return new Minion();
//}

/// <summary>
/// Permet seulement de vérifier si une position x/y est à l'intérieur du cercle
/// </summary>
/// <param name="posX">La position en x.</param>
/// <param name="PosY">La position en y.</param>
/// <returns></returns>
//Alex
bool Minion::cliquer(float posX, float posY)
{
	return getGlobalBounds().intersects(FloatRect(posX, posY, 1, 1));
}
//Alex
void Minion::bouger(Liste<Minion>* minionList)
{
	//Une destination nulle pas de mouvement
	if (target != nullptr)
	{
		//On sauvegarde la position précédente au cas
		positionBackup = new Vector2f(getPosition());

		//On effectue le déplacement
		Transformable::move(cos(angle) * speed, sin(angle) * speed);

		//Vue la faible vitesse et pour garder les choses simples, s'il y a collision, on annule 
		//tout simplement le mouvement pour ce refresh de frame et on termine la méthode immédiatement
		for (int i = 0; i < minionList->getNbElements(); i++)
		{
			if (testCollisionMinion((minionList->at(i))))
			{
				backup();
				return;
			}
		}

		//À PARTIR D'ICI C'EST QU'IL N'Y A PAS EU DE COLLISION

		//Avec les float, il faut accepter un seuil de tolérance, quand on arrive à distance de la "vitesse" visé, on considère avoir atteint notre destination
		if ((abs(target->x - getPosition().x) <= speed) && (abs(target->y - getPosition().y) <= speed))
		{
			//On la fixe, pour être certain
			setPosition(*target);

			//On arrête de bouger
			calculerAngle();
		}

		//Dans tous les cas, pour éviter les leaks on libère le backup
		cleanBackup();
	}
}
//Alex
void Minion::backup()
{
	if (positionBackup != nullptr)
	{
		setPosition(*positionBackup);
		delete positionBackup;
		positionBackup = nullptr;
	}
}
//Alex
void Minion::cleanBackup()
{
	if (positionBackup != nullptr)
	{
		delete positionBackup;
		positionBackup = nullptr;
	}
}

/// <summary>
/// Tester la collision des Minions.  Algo de collision des cercles que vous connaissez déjà
/// </summary>
/// <param name="autreMinion">The autre Minion.</param>
/// <returns>vrai si nous sommes en colision avec un autre Minion, sionon faux</returns>
//Alex
bool Minion::testCollisionMinion(Minion* autreMinion)
{
	//S'assurer qu'on est pas avec null ou avec sois-même.  parce qu'on collisionne toujours avec soit-même...
	if (autreMinion == nullptr || autreMinion == this)
	{
		return false;
	}

	return getGlobalBounds().intersects(autreMinion->getGlobalBounds());
}

/// <summary>
/// donne un projectile qui va dans la direction du target du minion
/// </summary>
//Alex
Projectile * Minion::attack()
{
	if (attackTime.getElapsedTime().asMilliseconds() >= (int)(range / speed))
	{
		attackTime.restart();
		return new Projectile(speed, attackPoints, range, angle, isAlly);
	}
	else
	{
		return nullptr;
	}
}

Vector2f* Minion::getTarget()
{
	return target;
}

int Minion::getCout()
{
	return cout;
}

int Minion::getRange()
{
	return range;
}

int Minion::getAttackPoints()
{
	return attackPoints;
}

int Minion::getSpeed()
{
	return speed;
}
/// <summary>
/// ajoute une destination donnée
/// ne pas oublier d'appler calculerAngle lorque nous voulons utiliser le contenu de la liste
/// </summary>
/// <param name="autreMinion">la destination à ajouter</param>
//Alex
void Minion::AjouterDestination(Vector2f destination)
{
	ordreAAttaquer.Push(&destination);
}

/// <summary>
/// met la prochaine destination et calcule l'angle d'attaque
/// </summary>
//Alex
void Minion::calculerAngle()
{
	target = ordreAAttaquer.Pop();

	//On calcule l'angle pour la direction de la soul.
	angle = atanf((target->y - getPosition().y) / (target->x - getPosition().x));

	if (target->x < getPosition().x)
	{
		angle += M_PI;
	}
}
/// <summary>
/// trouve si un ennemie est à porté d'attaque et le met comme sa cible
/// </summary>
/// <returns>vrai si nous avons trouvé un ennemie à porté, sionon faux</returns>
//Alex
bool Minion::lookForEnnemies(Liste<Minion>* minionList)
{
	for (int i = 0; i < minionList->getNbElements(); i++)
	{
		if (minionList->at(i)->getIsAlly() != isAlly && sqrt(pow(getPosition().x - minionList->at(i)->getPosition().x, 2) +
			pow(getPosition().y - minionList->at(i)->getPosition().y, 2)) <= range)
		{
			ordreAAttaquer.Push(new Vector2f(minionList->at(i)->getPosition()));
			calculerAngle();
			return true;
		}
	}
	return false;
}

bool Minion::getIsFacingLeft()
{
	return isFacingLeft;
}

void Minion::notifier(Sujet * sujet)
{
	//sujet->notifierTousLesObservateurs();
}

int Minion::getID()
{
	return ID;
}
//Alex
int Minion::getIsAlly()
{
	return isAlly;
}




////LES OPERATORS!!!


bool Minion::operator < (const Minion& minion)
{
	return this->ID < minion.ID;
}

bool Minion::operator >(const Minion& minion)
{
	return this->ID > minion.ID;
}

bool Minion::operator >= (const Minion& minion)
{
	return this->ID >= minion.ID;
}

bool Minion::operator <= (const Minion& minion)
{
	return this->ID <= minion.ID;
}

bool Minion::operator == (const Minion& minion)
{
	return this->ID == minion.ID;
}

bool Minion::operator != (const Minion& minion)
{
	return this->ID != minion.ID;
}