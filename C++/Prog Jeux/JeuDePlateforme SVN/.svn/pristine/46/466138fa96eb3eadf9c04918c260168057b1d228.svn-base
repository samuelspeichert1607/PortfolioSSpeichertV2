#include "Player.h"

Texture Player::texture;

Player::Player(const float posX, const float posY, RenderWindow* const renderWindow) : renderWindow(renderWindow), cadran(6), animateur(0), animateurImmobile(0), directionImmobile(1), estMobile(false)
{
	setPosition(posX, posY);
}

Player::~Player()
{
	for (size_t i = 0; i < NBR_NIVEAUX; i++)
	{
		delete[] intRectsImmobile[i];
		delete[] intRectsMouvement[i];
	}
	delete[] intRectsImmobile;
	delete[] intRectsMouvement;
}

bool Player::chargerTextures(const char texturePath[])
{
	if (!texture.loadFromFile(texturePath))
	{
		return false;
	}

	texture.setSmooth(false);
	return true;
}

void Player::ajustementsVisuels()
{
	setTexture(texture);

	for (size_t i = 0; i < NBR_NIVEAUX; i++)
	{
		intRectsImmobile[i] = new IntRect[NBR_ANIMS_IMMOBILE];
		intRectsMouvement[i] = new IntRect[NBR_ANIMS_MOUVEMENT];
		intRectsJump[i] = new IntRect[NBR_ANIMS_JUMP];
		intRectsMort[i] = new IntRect[NBR_ANIMS_MORT];
		intRectsVictoire[i] = new IntRect[NBR_ANIMS_VICTOIRE];

		int hauteur = texture.getSize().y / NBR_NIVEAUX;

		for (size_t j = 0; i < NBR_ANIMS_IMMOBILE; i++)
		{
			int largeur = texture.getSize().x / NBR_ANIMS_IMMOBILE;
			intRectsImmobile[i][j].left = largeur * j;
			intRectsImmobile[i][j].top = hauteur * j;
			intRectsImmobile[i][j].width = largeur;
			intRectsImmobile[i][j].height = hauteur;
		}

		for (size_t j = 0; i < NBR_ANIMS_MOUVEMENT; i++)
		{
			int largeur = texture.getSize().x / NBR_ANIMS_MOUVEMENT;
			intRectsImmobile[i][j].left = largeur * j;
			intRectsImmobile[i][j].top = hauteur * j;
			intRectsImmobile[i][j].width = largeur;
			intRectsImmobile[i][j].height = hauteur;
		}
	}

	setTextureRect(intRectsImmobile[cadran][0]);
	setOrigin(intRectsImmobile[0][0].height / 2, intRectsImmobile[0][0].width / 2);
}